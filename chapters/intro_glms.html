<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>intro_glms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="intro_glms_files/libs/clipboard/clipboard.min.js"></script>
<script src="intro_glms_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="intro_glms_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="intro_glms_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="intro_glms_files/libs/quarto-html/popper.min.js"></script>
<script src="intro_glms_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="intro_glms_files/libs/quarto-html/anchor.min.js"></script>
<link href="intro_glms_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="intro_glms_files/libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="intro_glms_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="intro_glms_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="intro_glms_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">intro_glms</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="separating-signal-from-noise" class="level2">
<h2 class="anchored" data-anchor-id="separating-signal-from-noise">Separating signal from noise</h2>
<p>Our task, then, is to separate the patterns that carry meaningful information from the variation that does not. This task leads directly to the ideas of <em>signal</em> and <em>noise</em> and to why we use all of these silly models in the first place. So, what exactly are models?</p>
<blockquote class="blockquote">
<p>Models are hypotheses about how the data were generated.</p>
</blockquote>
<section id="glms-versus-anovas-and-t-tests" class="level3">
<h3 class="anchored" data-anchor-id="glms-versus-anovas-and-t-tests">5. GLMs versus ANOVAs and <em>t</em>-tests</h3>
<p>Then GLMs stop being <em>“advanced statistics”</em> and become:</p>
<blockquote class="blockquote">
<p>a formal language for ecological thinking ### Key ideas</p>
</blockquote>
<ul>
<li><em>t</em>-tests and ANOVAs are <strong>linear models</strong></li>
<li>They assume:
<ul>
<li>Gaussian errors</li>
<li>identity link</li>
</ul></li>
<li>Group means = predictors with factor coding</li>
</ul>
<p><strong>Crucial reframing:</strong><br>
&gt; We don’t abandon ANOVAs — we outgrow them.</p>
<div class="columns">
<div class="column" style="width:60%;">
<p>In this brief example, we provide some simulation code that will (hopefully) convince you that GLMs are pretty much the same kinds of models that you were exposed to in your introductory statistics courses back in the day. As you’ll quickly see, however, GLMs are highly flexible and will allow you to extract the maximum amount of signal from your noisy data.</p>
<p>We will simulate a fake dataset that has two groups (1 and 2). The values for each group follow normal distributions with a standard deviation of 1. The groups differ in their mean values, however, by one unit.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">100</span>) <span class="co"># this is a random seed that ensures example reproducibility</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>nval <span class="ot">&lt;-</span> <span class="dv">50</span> <span class="co"># Generate some fake data</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>group1 <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(nval, <span class="at">mean=</span><span class="dv">5</span>, <span class="at">sd=</span><span class="dv">1</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>group2 <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(nval, <span class="at">mean=</span><span class="dv">6</span>, <span class="at">sd=</span><span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id=</span><span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"group1"</span>, <span class="st">"group2"</span>), <span class="at">each=</span>nval), </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">y=</span><span class="fu">c</span>(group1, group2))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</div><div class="column" style="width:40%;">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="intro_glms_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
</div>
<p>Now, using three models (<em>t</em>-test, ANOVA, and GLM), let us test the hypothesis that these two groups differ. Note that we need to convert the ANOVA’s <em>F</em>-stat to a <em>t</em>-statistic for comparability.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>R code for inter-model comparison
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ttest.mod <span class="ot">&lt;-</span> <span class="fu">t.test</span>(y <span class="sc">~</span> id, <span class="at">data=</span>d) <span class="co"># t-test</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>anova.mod <span class="ot">&lt;-</span> <span class="fu">aov</span>(y <span class="sc">~</span> id, <span class="at">data=</span>d) <span class="co"># ANOVA</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>glm.mod <span class="ot">&lt;-</span> <span class="fu">glm</span>(y <span class="sc">~</span> id, <span class="at">data=</span>d) <span class="co"># GLM</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ttest.t <span class="ot">&lt;-</span> <span class="fu">abs</span>(<span class="fu">as.numeric</span>(ttest.mod<span class="sc">$</span>statistic))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>anova.f <span class="ot">&lt;-</span> <span class="fu">summary</span>(anova.mod)[[<span class="dv">1</span>]]<span class="sc">$</span>F[<span class="dv">1</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>anova.t <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(anova.f) <span class="co"># t-stat = sqrt(F-stat)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>glm.t <span class="ot">&lt;-</span> <span class="fu">coefficients</span>(<span class="fu">summary</span>(glm.mod))[<span class="dv">2</span>, <span class="dv">3</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Then, we compare all the test statistics.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.119985 4.119985 4.119985</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Whew…all of the results are exactly the same (4.119985). Fantastic! Now you can sit back and silently vow never to use a <em>t</em>-test or ANOVA (or anything similar) again. Take a moment (for five) and do that now. Seriously, take a moment (and write to your college stats instructor) and then consult the following table to understand the flexibility of GLMs.</p>
<div class="course-info" data-tbl-colwidths="[70, 10, 10, 10]">
<table class="caption-top table">
<colgroup>
<col style="width: 70%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th>Functionality / Capability</th>
<th style="text-align: center;">t-test</th>
<th style="text-align: center;">ANOVA</th>
<th style="text-align: center;">GLM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Unbalanced sample</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td>Compare more than two groups</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="odd">
<td>Handle continuous predictors</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td>Handle non-Normal distributions</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="odd">
<td>Complex hierarchical random effects</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td>Use link functions (log, logit, etc.)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="odd">
<td>Predicted values from model output</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="even">
<td>Nonlinear extensions</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
<tr class="odd">
<td>Under current development</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✅</td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="setting-the-st" class="level3">
<h3 class="anchored" data-anchor-id="setting-the-st">Setting the st</h3>
<p>Most treatments of GLMs start off examining a model with Gaussian (normally distributed) errors. The Gaussian models has core assumptions that are likely familiar and comfortable to most of you, including:</p>
<ul>
<li>The response variable is <strong>continuous</strong></li>
<li>The residual variance is <strong>constant</strong> (homoscedastic)</li>
<li>The error distribution is <strong>symmetric</strong></li>
<li>The outcome can take <strong>any real value</strong> (including negatives)</li>
</ul>
<p>In many situations, that works beautifully. If we are modeling body mass of adults (<em>why adults?</em>), temperature, or some other roughly symmetric continuous variable, the Gaussian/normal distribution is often appropriate. Simply put, the Gaussian/normal distribution is often the exception rather than the rule:</p>
<blockquote class="blockquote">
<p>Most ecological data are not normally distributed.</p>
</blockquote>
<p>We regularly collect data on proportions, rates, skewed measurements, zero-heavy processes, and, perhaps most commonly, counts like:</p>
<ul>
<li>Number of individuals observed<br>
</li>
<li>Number of detections on a recorder<br>
</li>
<li>Number of nests in a plot<br>
</li>
<li>Number of disease cases</li>
</ul>
<p>Count distributions –like the Poisson distribution– have their own features, including:</p>
<ul>
<li>Values cannot be negative.</li>
<li>Values are discrete (not continuous)</li>
<li>They often have variance that increases with the mean</li>
<li>They are frequently right-skewed</li>
</ul>
<p>A Gaussian model ignores almost everything about how the data are generated. Therefore, in this section, we will first explore the Poisson GLM, which is designed specifically for count data. It:</p>
<ul>
<li>Restricts predictions to non-negative values.</li>
<li>Allows variance to increase with the mean.</li>
</ul>
<p>Furthermore, using a Poisson GLM allows you to see the internal architecture of a GLM. It is a bit more difficult to see how a GLM works when using a Gaussian distribution. In a Poisson GLM, the GLM components are clearly delineated:</p>
<ul>
<li>The <strong>error distribution</strong> describes the noise.</li>
<li>The <strong>linear predictor</strong> describes the signal.</li>
<li>The <strong>link function</strong> connects the expected value of the response to the linear predictor</li>
</ul>
<p>Because those parts are visibly distinct, the Poisson model makes it much easier to understand what a GLM is actually doing.</p>
<hr>
</section>
</section>
<section id="the-poisson-glm-model-specification" class="level2">
<h2 class="anchored" data-anchor-id="the-poisson-glm-model-specification">The Poisson GLM: Model Specification</h2>
<p>For observations <span class="math inline">\(i = 1, \dots, n\)</span>:</p>
<section id="random-component-noise" class="level3">
<h3 class="anchored" data-anchor-id="random-component-noise">1️⃣ Random Component (Noise)</h3>
<p><span class="math inline">\(Y_i \sim \text{Poisson}(\mu_i)\)</span></p>
<p>Definitions:</p>
<ul>
<li><span class="math inline">\(Y_i\)</span>: observed count for observation <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(\mu_i\)</span>: expected (mean) count for observation <span class="math inline">\(i\)</span></li>
</ul>
<p>For a Poisson distribution:</p>
<p><span class="math inline">\(E(Y_i) = \mu_i\)</span></p>
<p><span class="math inline">\(\text{Var}(Y_i) = \mu_i\)</span></p>
<p>This component specifies how observations vary <strong>stochastically</strong> around their mean.<br>
It defines the allowable values (non-negative integers) and how variance scales with the mean.</p>
<hr>
</section>
<section id="systematic-component-signal" class="level3">
<h3 class="anchored" data-anchor-id="systematic-component-signal">2️⃣ Systematic Component (Signal)</h3>
<p><span class="math inline">\(\eta_i = \beta_0 + \beta_1 X_i\)</span></p>
<p>Definitions:</p>
<ul>
<li><span class="math inline">\(\eta_i\)</span> (eta): the <strong>linear predictor</strong></li>
<li><span class="math inline">\(\beta_0\)</span>: intercept</li>
<li><span class="math inline">\(\beta_1\)</span>: slope parameter</li>
<li><span class="math inline">\(X_i\)</span>: predictor value for observation <span class="math inline">\(i\)</span></li>
</ul>
<p>This part represents the <strong>structured, directional effect</strong> of predictors.<br>
It is deterministic — no randomness appears here.</p>
<hr>
</section>
<section id="link-function-connector" class="level3">
<h3 class="anchored" data-anchor-id="link-function-connector">3️⃣ Link Function (Connector)</h3>
<p><span class="math inline">\(\log(\mu_i) = \eta_i\)</span></p>
<p>Equivalently:</p>
<p><span class="math inline">\(\mu_i = \exp(\eta_i)\)</span></p>
<p>The link function connects the linear predictor to the mean of the distribution.</p>
<p>Why the log link?</p>
<ul>
<li>It guarantees <span class="math inline">\(\mu_i &gt; 0\)</span>.</li>
<li>It makes effects multiplicative on the response scale.</li>
<li>It keeps linearity on a scale where it makes sense.</li>
</ul>
<hr>
</section>
</section>
<section id="compact-form" class="level2">
<h2 class="anchored" data-anchor-id="compact-form">Compact Form</h2>
<p><span class="math inline">\(Y_i \sim \text{Poisson}(\mu_i)\)</span><br>
<span class="math inline">\(\log(\mu_i) = \beta_0 + \beta_1 X_i\)</span></p>
<hr>
</section>
<section id="big-picture" class="level2">
<h2 class="anchored" data-anchor-id="big-picture">Big Picture</h2>
<p>A GLM separates:</p>
<ul>
<li><strong>Signal</strong> → why the mean changes (linear predictor)<br>
</li>
<li><strong>Noise</strong> → how observations vary around that mean (distribution)<br>
</li>
<li><strong>Link</strong> → how the structured signal maps to biologically allowable values</li>
</ul>
<p>That separation is the real power of the GLM framework.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>